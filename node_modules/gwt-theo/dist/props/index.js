"use strict";

var path = require("path");
var _ = require("lodash");
var through = require("through2");
var gulpu = require("gulp-util");
var tinycolor = require("tinycolor2");

var util = require("./util");
var constants = require("./util/constants");
var TheoError = require("./util/error");

var PropSet = require("./prop-set");

var kebabCase = require("lodash/string/kebabCase");

////////////////////////////////////////////////////////////////////
// Helpers
////////////////////////////////////////////////////////////////////

function cleanOutput(output) {
  return output.replace(/^    /gm, "").replace(/^\s*\n/gm, "").trim();
}

function remToPx(prop, meta) {
  var baseFontPercentage = typeof meta.baseFontPercentage === "number" ? meta.baseFontPercentage : 100;
  var baseFontPixel = typeof meta.baseFontPixel === "number" ? meta.baseFontPixel : 16;
  return util.remToPx(prop.value, baseFontPercentage, baseFontPixel);
}

function getWarning() {
  var warning = "/**\n";
  warning += " * -> WARNING, this is a generated file. Use GWT-Theo if you want to modify it.\n";
  warning +=" */\n\n";
  return warning;
}

////////////////////////////////////////////////////////////////////
// Value Transforms
////////////////////////////////////////////////////////////////////

var VALUE_TRANSFORMS = {};

function registerValueTransform(name, matcher, transformer) {
  if (typeof name !== "string") {
    throw TheoError("valueTransform name must be a string");
  }
  if (typeof matcher !== "function") {
    throw TheoError("valueTransform matcher must be a function");
  }
  if (typeof transformer !== "function") {
    throw TheoError("valueTransform transformer must be a function");
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  };
}

registerValueTransform("color/rgb", function (prop) {
  return prop.type === "color";
}, function (prop) {
  return tinycolor(prop.value).toRgbString();
});

registerValueTransform("color/hex", function (prop) {
  return prop.type === "color";
}, function (prop) {
  return tinycolor(prop.value).toHexString();
});

registerValueTransform("color/hex8", function (prop) {
  return prop.type === "color";
}, function (prop) {
  return tinycolor(prop.value).toHex8String();
});

registerValueTransform("percentage/float", function (prop) {
  return prop.value.match(/%/) !== null;
}, function (prop) {
  return prop.value.replace(constants.PERCENTAGE_PATTERN, function (match, number) {
    return parseFloat(number / 100);
  });
});

registerValueTransform("relative/pixel", function (prop) {
  return util.isRelativeSpacing(prop.value);
}, function (prop, meta) {
  return remToPx(prop, meta);
});

registerValueTransform("relative/pixelValue", function (prop) {
  return util.isRelativeSpacing(prop.value);
}, function (prop, meta) {
  return remToPx(prop, meta).replace(/px$/g, "");
});

////////////////////////////////////////////////////////////////////
// Transforms
////////////////////////////////////////////////////////////////////

var TRANSFORMS = {};

function registerTransform(name, valueTransforms) {
  if (typeof name !== "string") {
    throw TheoError("transform name must be a string");
  }
  if (!_.isArray(valueTransforms)) {
    throw TheoError("valueTransforms must be an array of registered value transforms");
  }
  valueTransforms.forEach(function (t) {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError("valueTransforms must be an array of registered value transforms");
    }
  });
  TRANSFORMS[name] = valueTransforms;
}

registerTransform("raw", []);

registerTransform("web", ["color/rgb"]);

registerTransform("ios", ["color/rgb", "relative/pixelValue", "percentage/float"]);

////////////////////////////////////////////////////////////////////
// Formats
////////////////////////////////////////////////////////////////////

var FORMATS = {};

function registerFormat(name, formatter) {
  if (typeof name !== "string") {
    throw TheoError("format name must be a string");
  }
  if (typeof formatter !== "function") {
    throw TheoError("format formatter must be a function");
  }
  FORMATS[name] = formatter;
}

registerFormat("json", function (json) {
  var output = {};
  _.forEach(json.props, function (prop) {
    output[prop.name] = prop.value;
  });
  return JSON.stringify(output, null, 2);
});

registerFormat("raw.json", function (json) {
  return JSON.stringify(json, null, 2);
});

registerFormat("sass", function (json) {
  return _.map(json.props, function (prop) {
    var name = kebabCase(prop.name);
    return "$" + name + ": " + prop.value;
  }).join("\n");
});

registerFormat("less", function (json) {
  return _.map(json.props, function (prop) {
    var name = kebabCase(prop.name);
    return "@" + name + ": " + prop.value + ";";
  }).join("\n");
});

registerFormat("html", require("./formats/html"));

registerFormat("gss", function (json, gwt) {
  var classname, header, defs;

  header = getWarning() + "@provide '" + gwt.name + "';\n";

  defs = _.map(json.props, function (prop) {
    var title = "";
    if(classname != prop.classname) {
      classname = prop.classname;
      title = "\n/**\n * " + classname + "\n */\n\n";
    }
    if(prop.name.indexOf("title-") != -1) {
      return title;
    }
    return title + "@def " + prop.name + " eval(\"" + gwt.pckg + "." + prop.classname + "." + prop.name + "\");\n";
  }).join("");

  return header + defs;
});

registerFormat("java", function (json, gwt) {
  var header = getWarning() + "package " + gwt.pckg + ";\n\n";
  header += "public class " + json.props[0].classname + " {\n";
  
  var props = _.map(json.props, function (prop) {
    var title = "";
    if(prop.name.indexOf("title-") != -1) {
      return "    /* -> " + prop.value + " -- */";
    }
    return title + "    public static final String " + prop.name + " = \"" + prop.value + "\";";
  }).join("\n");

  return header + props + "\n}\n";
});

registerFormat("icons", function (json, gwt) {
  var header = getWarning() + "package " + gwt.pckg + ";\n\n";
  header += "import com.google.gwt.resources.client.ClientBundle;\n";
  header += "import com.google.gwt.resources.client.CssResource;\n";
  header += "import com.google.gwt.resources.client.DataResource;\n\n";
  header += "public interface ThemeResources extends ClientBundle {\n";
  header += "\tinterface Icons extends CssResource {";

  var prefix = json.preferences.fontPref.prefix;
  
  var props = _.map(json.icons, function (icon) {
    return "\n\t\tString " + prefix + icon.properties.name + "();";
  }).join("\n");

  var footer = "\t@Source(\"fonts/icons/icons.ttf\")\n";
  footer += "\tDataResource iconsTtf();\n";
  footer += "\n";
  footer += "\t@Source(\"fonts/icons/icons.eot\")\n";
  footer += "\tDataResource iconsEot();\n";
  footer += "\n";
  footer += "\t@Source(\"fonts/icons/icons.svg\")\n";
  footer += "\tDataResource iconsSvg();\n";
  footer += "\n";
  footer += "\t@Source(\"fonts/icons/icons.woff\")\n";
  footer += "\tDataResource iconsWoff();\n";
  footer += "\n";
  footer += "\t@Source(\"fonts/icons/icons.gss\")\n";
  footer += "\tIcons icons();\n";

  return header + props + "\n\t}\n\n" + footer + "}\n";
});

////////////////////////////////////////////////////////////////////
// Exports
////////////////////////////////////////////////////////////////////

module.exports = {

  /**
   * Helpers that return transform streams
   */
  plugins: {

    /**
     * Transform legacy Theo Design Props
     */
    legacy: function legacy() {
      return through.obj(function (file, enc, next) {
        var newFile = file.clone();
        var json;
        try {
          json = util.parsePropsFile(newFile);
          if (_.isArray(json)) {
            var err = TheoError("legacy() encountered a non object Design Properties file: " + newFile.path);
            return next(err);
          }
        } catch (e) {
          var err = TheoError("legacy() encountered an invalid Design Properties file: " + newFile.path);
          return next(err);
        }
        // Theme
        if (_.has(json, "theme")) {
          // Properties
          if (_.isArray(json.theme.properties)) {
            json.props = {};
            for (var i = 0; i < json.theme.properties.length; i++) {
              var prop = json.theme.properties[i];
              if (typeof prop.name === "undefined") {
                var err = TheoError("legacy() encountered a property with no \"name\" key: " + newFile.path);
                return next(err);
              }
              var _name = prop.name;
              delete prop.name;
              json.props[_name] = prop;
            }
          }
          // Aliases
          if (_.isArray(json.theme.aliases)) {
            var aliases = json.theme.aliases;
            json.aliases = {};
            _.forEach(aliases, function (alias) {
              json.aliases[alias.name] = alias.value;
            });
          }
          // Cleanup
          delete json.theme;
        }
        if (_.isArray(json.aliases)) {
          var aliases = json.aliases;
          json.aliases = {};
          _.forEach(aliases, function (alias) {
            json.aliases[alias.name] = alias.value;
          });
        }
        // Done
        newFile.contents = new Buffer(JSON.stringify(json, null, 2));
        next(null, newFile);
      });
    },

    /**
     * Transform the prop values
     *
     * @param {string} type
     */
    transform: function transform(type) {
      var options = arguments[1] === undefined ? {} : arguments[1];
      var defaults = {
        includeAlias: false,
        includeMeta: false
      };
      if (typeof options !== "undefined" && typeof options !== "object") {
        throw TheoError("transform() options must be an object");
      }
      options = _.merge({}, defaults, options);
      if (!_.has(TRANSFORMS, type)) {
        var err = TheoError("\"" + type + "\" is not a registered transform");
        return next(err);
      }
      var transform = TRANSFORMS[type].map(function (name) {
        return VALUE_TRANSFORMS[name];
      });
      return through.obj(function (file, enc, next) {
        var newFile = file.clone();
        try {
          newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer();
        } catch (err) {
          return next(err);
        }
        next(null, newFile);
      });
    },

    /**
     * Convert the vinyl '.json' file to a JSON primative
     *
     * @param {function} [callback]
     * @return {stream}
     */
    getResult: function getResult(callback) {
      return through.obj(function (file, enc, next) {
        if (typeof callback === "function" && file.isBuffer()) {
          var result = file.contents.toString();
          callback(result);
          return next(null, file);
        }
      });
    },

    /**
     * Format the props JSON into a new output format
     *
     * @param {string} type
     * @param {object} options
     * @param {function} [options.propsFilter] - A function that filters props before formatting
     */
    format: function format(type) {
      var options = arguments[1] === undefined ? {} : arguments[1];
      var defaults = {
        propsFilter: function () {
          return true;
        }
      };
      if (typeof options !== "object") {
        throw TheoError("format() options must be an object");
      }
      options = _.merge({}, defaults, options);
      if (typeof options.propsFilter !== "function") {
        throw TheoError("format() options.filter must be a function");
      }
      // Get the formatter
      if (typeof FORMATS[type] === "undefined") {
        throw TheoError("\"" + type + "\"\" is not a registerd format");
      }
      var formatter = FORMATS[type];
      return through.obj(function (file, enc, next) {
        var newFile = file.clone();
        // Get the transformed JSON
        var json = util.parsePropsFile(newFile);
        // Rename the file
        newFile.path = newFile.path.replace(/(json|yml)$/, type);
        // Filter out any props that won't be needed for this format
        json.props = _.filter(json.props, options.propsFilter);
        // Format the json
        var formatted = formatter(json, options);
        // Set the file contents to the result of the formatter
        newFile.contents = new Buffer(formatted);
        next(null, newFile);
      });
    },

    /**
     * Diff props
     */
    diff: function diff() {
      var options = arguments[0] === undefined ? {} : arguments[0];
      var defaults = {
        name: "diff"
      };
      if (typeof options !== "object") {
        throw TheoError("diff() options must be an object");
      }
      options = _.merge({}, defaults, options);
      if (typeof options.name !== "string") {
        throw TheoError("diff() options.name must be a string");
      }
      var propSets = [];
      function transform(file, enc, next) {
        var ext = path.extname(file.relative);
        if (ext === ".json" || ext === ".yml") {
          try {
            var json = util.parsePropsFile(file);
            propSets.push(json);
          } catch (e) {
            var err = TheoError("diff() encountered an invalid Design Properties file", file.path);
            return next(err);
          }
        }
        next();
      }
      function flush(next) {
        var log = {
          changed: {},
          added: {},
          removed: {}
        };
        var a = propSets[0].props;
        var b = propSets[1].props;
        _.forEach(a, function (prop, name) {
          // Change
          if (_.has(b, name)) {
            var _prop = b[name];
            if (prop.value !== _prop.value) {
              log.changed[name] = [prop.value, _prop.value];
            }
          }
          // Remove
          else {
            log.removed[name] = prop.value;
          }
        });
        _.forEach(b, function (prop, name) {
          // Add
          if (!_.has(a, name)) {
            log.added[name] = prop.value;
          }
        });
        var file = new gulpu.File({
          path: "" + options.name + ".json",
          contents: new Buffer(JSON.stringify(log, null, 2))
        });
        this.push(file);
        next();
      }
      return through.obj(transform, flush);
    }

  },

  /**
   * Register a new value transform. If a transform with the provided
   * name already exists it will be overwritten
   *
   * @param {string} name
   * @param {function(prop)} filter - a function that returns a true if the transform should be applied
   * @param {function(prop,meta)} - a function that should return the new prop value
   */
  registerValueTransform: registerValueTransform,

  /**
   * Check if a value transform exists
   *
   * @param {string} name
   */
  valueTransformIsRegistered: function valueTransformIsRegistered(name) {
    return typeof VALUE_TRANSFORMS[name] !== "undefined";
  },

  /**
   * Get a registered valueTransform
   *
   * @param {} name
   */
  getValueTransform: function getValueTransform(name) {
    if (!this.valueTransformIsRegistered(name)) {
      throw TheoError("\"" + name + "\" is not a registered valueTransform");
    }
    return _.merge({}, VALUE_TRANSFORMS[name]);
  },

  /**
   * Register a new transform. If a transform with the provided
   * name already exists it will be overwritten
   *
   * @param {string} name
   * @param {array} valueTransforms - a list of value transforms to be applied to the props
   */
  registerTransform: registerTransform,

  /**
   * Check if a transform exists
   *
   * @param {string} name
   */
  transformIsRegistered: function transformIsRegistered(name) {
    return typeof TRANSFORMS[name] !== "undefined";
  },

  /**
   * Get a registered format
   *
   * @param {} name
   */
  getTransform: function getTransform(name) {
    if (!this.transformIsRegistered(name)) {
      throw TheoError("\"" + name + "\" is not a registered transform");
    }
    return _.merge([], TRANSFORMS[name]);
  },

  /**
   * Register a new format. If a format with the provided
   * name already exists it will be overwritten
   *
   * @param {string} name
   * @param {function(json,[options])} formatter - a function that should return a string represenation of the new format
   */
  registerFormat: registerFormat,

  /**
   * Check if a transform exists
   *
   * @param {string} name
   */
  formatIsRegistered: function formatIsRegistered(name) {
    return typeof FORMATS[name] !== "undefined";
  },

  /**
   * Get a registered format
   *
   * @param {} name
   */
  getFormat: function getFormat(name) {
    if (!this.formatIsRegistered(name)) {
      throw TheoError("\"" + name + "\" is not a registered format");
    }
    return FORMATS[name];
  }
};