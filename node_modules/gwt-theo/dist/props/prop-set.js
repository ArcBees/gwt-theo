"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var path = require("path");
var fs = require("fs");
var _ = require("lodash");
var gulpu = require("gulp-util");
var util = require("./util");
var TheoError = require("./util/error");

var PropSet = (function () {
  function PropSet(file, valueTransforms) {
    var options = arguments[2] === undefined ? {} : arguments[2];
    _classCallCheck(this, PropSet);

    if (typeof file.isBuffer !== "function" || typeof file.isBuffer === "undefined") {
      throw TheoError("transform() must use vinyl files");
    }

    this.file = file;
    this.path = file.path;
    this.valueTransforms = valueTransforms;
    this.options = options;

    this._init();
  }

  _prototypeProperties(PropSet, null, {
    _init: {
      value: function _init() {
        // Create the definition
        var def = {
          global: {},
          aliases: {}
        };
        // Merge the JSON into the definition
        try {
          var json = util.parsePropsFile(this.file);
          def = _.merge(def, json);
        } catch (e) {
          throw TheoError("transform() encountered an invalid Design Properties file: " + this.file.path);
        }
        // Globals
        this._resolveGlobals(def);
        // Validate
        this._validate(def);
        // Resolve any local aliases before resolving imports
        this._resolveAliases(def);
        // Collect all the import definitions
        var imports = this._resolveImports(def).map(function (i) {
          return i.def;
        });
        // Merge the imported definitions
        def = _.merge.apply(null, _.flatten([{}, imports, def]));
        // Resolve any additional aliases that were depending on imports
        if (imports.length > 0) {
          this._resolveAliases(def);
        }
        // Cleanup
        delete def.global;
        delete def.imports;
        // Save
        this.def = def;
        return this;
      },
      writable: true,
      configurable: true
    },
    transform: {
      value: function transform() {
        this._transformProps();
        return this;
      },
      writable: true,
      configurable: true
    },
    toBuffer: {
      value: function toBuffer() {
        return new Buffer(this.toJSON());
      },
      writable: true,
      configurable: true
    },
    toJSON: {
      value: function toJSON() {
        // Create a copy
        var def = _.merge({}, this.def);
        // Provide the keys for easy iteration
        def.propKeys = _.keys(def.props);
        // Go
        return JSON.stringify(def, null, 2);
      },
      writable: true,
      configurable: true
    },
    _resolveGlobals: {
      value: function _resolveGlobals(def) {
        if (_.keys(def.global).length === 0) return;
        _.forEach(def.props, function (prop, key) {
          def.props[key] = _.merge({}, def.global, prop);
        });
        delete def.global;
      },
      writable: true,
      configurable: true
    },
    _validate: {
      value: function _validate(def) {
        if (!_.has(def, "props") || !_.isObject(def.props)) {
          //console.warn('Design Properties contained no "props" object')
          def.props = {};
        }
        // Make sure properties have all required keys
        _.forEach(def.props, function (prop, name) {
          ["value", "type", "category"].forEach(function (key) {
            if (!_.has(prop, key)) {
              throw TheoError("prop \"" + name + "\" contained no \"" + key + "\" key");
            }
          });
        });
      },
      writable: true,
      configurable: true
    },
    _resolveAliases: {
      value: function _resolveAliases(def) {
        var options = this.options;
        _.forEach(def.aliases, function (value, key) {
          var s = _.escapeRegExp(key);
          var re = new RegExp("{!" + s + "}", "g");
          var isAlias = /^{[^\}]*}$/g;
          _.forEach(def.props, function (prop) {
            if (_.isString(prop.value)) {
              // Value contains an alias
              if (re.test(prop.value)) {
                // See if the alias should be included in the prop
                if (options.includeAlias === true && isAlias.test(prop.value)) {
                  prop.alias = key;
                }
                // Reslove the alias
                prop.value = prop.value.replace(re, value);
              }
            }
          });
        });
      },
      writable: true,
      configurable: true
    },
    _resolveImports: {
      value: function _resolveImports(def) {
        var _this = this;
        if (!_.isArray(def.imports)) return [];
        return def.imports.map(function (i) {
          var p = path.resolve(path.dirname(_this.path), i);
          if (!fs.existsSync(p)) {
            throw TheoError("Import not found: " + p);
          }
          var f = fs.readFileSync(p);
          if (!f) {
            throw TheoError("Import not found: " + p);
          }
          var v = new gulpu.File({
            path: p,
            contents: new Buffer(f)
          });
          return new PropSet(v, _this._transform, _this.options);
        });
      },
      writable: true,
      configurable: true
    },
    _transformProps: {
      value: function _transformProps() {
        var _this = this;
        _.forEach(this.def.props, function (prop, name) {
          // Move the name into the prop for use in the transformer
          if (!_.has(prop, "name")) {
            prop.name = name;
          }
          // Extract the meta data
          var meta = prop[".meta"];
          if (_this.options.includeMeta !== true) {
            delete prop[".meta"];
          }
          // Transform the value
          _this._transformValue(prop, meta);
        });
      },
      writable: true,
      configurable: true
    },
    _transformValue: {
      value: function _transformValue(prop, meta) {
        _.forEach(this.valueTransforms, function (v) {
          var p = _.merge({}, prop);
          var m = _.merge({}, meta);
          if (v.matcher(p, m) === true) {
            prop.value = v.transformer(p, m);
          }
        });
      },
      writable: true,
      configurable: true
    }
  });

  return PropSet;
})();

module.exports = PropSet;